
-- https://huggingface.co/login?next=%2Fsettings%2Ftokens local api_key = "" -- put api key here between quotes httprequest = (syn and syn.request) or (http and http.request) or http_request or (fluxus and fluxus.request) or request or HttpPost function asset(id) return "http://www.roblox.com/asset/?id=" .. tostring(id) end local noImg = asset(0) local Debounce = false local UILib = loadstring(game:HttpGet('https://raw.githubusercontent.com/StepBroFurious/Script/main/HydraHubUi.lua'))() local Window = UILib.new("RoGPT", game.Players.LocalPlayer.UserId, "Happy Hax") local AiCategory = Window:Category("AI",noImg) local ModelsButton = AiCategory:Button("Models",noImg) local PersonalityButton = AiCategory:Button("Personality",noImg) --model selection local ModelSection = ModelsButton:Section("AI Models", "Left") models = { ["Options"] = { ["DialoGPT (smart)"] = "https://api-inference.huggingface.co/models/microsoft/DialoGPT-large", ["DialoGPT (sarcasm)"] = "https://api-inference.huggingface.co/models/abhiramtirumala/DialoGPT-sarcastic", ["BlenderBot (400M)"] = "https://api-inference.huggingface.co/models/facebook/blenderbot-400M-distill", ["BlenderBot (3B)"]= "https://api-inference.huggingface.co/models/facebook/blenderbot-3B", ["Shuan (gen z)"] = "https://api-inference.huggingface.co/models/mywateriswet/ShuanBot", ["Peter (romance)"] = "https://api-inference.huggingface.co/models/DB13067/Peterbot", ["Idiot"] = "https://api-inference.huggingface.co/models/Pi3141/DialoGPT-medium-elon-3", ["Baek"] = "https://api-inference.huggingface.co/models/Zixtrauce/BaekBot", ["Joshua"] = "https://api-inference.huggingface.co/models/satvikag/chatbot", ["Kurisu"] = "https://api-inference.huggingface.co/models/DeliveryBoy/DiabloGPT-medium-Kurisu", ["Tony Stark"] = "https://api-inference.huggingface.co/models/KhanAdeeb/model-tony-stark", ["Shintaro"] = "https://api-inference.huggingface.co/models/MarinHinawa/DialoGPT-medium-Shintaro", --["Bloom (Text Completion)"] = "https://api-inference.huggingface.co/models/bigscience/bloom", -- incompatible. removed for now }, ["Multi"] = false, ["Default"] = "BlenderBot (400M)", ["Title"] = "HF AI", } models1 = {} for i,v in pairs(models.Options) do models1[i] = v end local cModel local cModelName ModelSection:Dropdown(models, function(options) for i,v in pairs(options) do if v == true then cModel = models1[i] cModelName = i end end print("selected ", cModel) end, noImg) --ai parameters local temperature local repPenalty local topK local topP local useTopK local useTopP local minTokens local maxTokens --personality selection local function noInt(n) if n%1 == 0 then if n > 0.0005 then n = n - 0.0005 else n = n + 0.0005 end end return n end local PersonalitySection = PersonalityButton:Section("Personality Parameters", "Left") PersonalitySection:Slider({ ["Title"] = "Temperature", ["Description"] = "Craziness of the AI", ["Min"] = 0, ["Max"] = 100, ["Default"] = 1, }, function(n) temperature = noInt(n) end) PersonalitySection:Slider({ ["Title"] = "Rep Penalty", ["Description"] = "Decreases repetition", ["Min"] = 0, ["Max"] = 100, ["Default"] = 1, }, function(n) repPenalty = noInt(n) end) PersonalitySection:Slider({ ["Title"] = "Top K", ["Description"] = "Variety", ["Min"] = 0, ["Max"] = 100, ["Default"] = 0, }, function(n) topK = math.round(n) end) PersonalitySection:Slider({ ["Title"] = "Top P", ["Description"] = "Creativity", ["Min"] = 0, ["Max"] = 300, ["Default"] = 0, }, function(n) topP = noInt(n)/100 end) PersonalitySection:Checkbox({ ["Title"] = "Use Top K", ["Description"] = "Enables Top K", ["Default"] = false, }, function(bool) useTopK = bool end) PersonalitySection:Checkbox({ ["Title"] = "Use Top P", ["Description"] = "Enables Top P", ["Default"] = false, }, function(bool) useTopP = bool end) local maxTokensBound = 300 local LengthSection = PersonalityButton:Section("Response Length Parameters", "Right") local minSlider = LengthSection:Slider({ ["Title"] = "Min Tokens", ["Description"] = "Tokens are 1-3 letters", ["Min"] = 0, ["Max"] = maxTokensBound, ["Default"] = 7, }, function(n) minTokens = math.round(n) if maxTokens and (minTokens > maxTokens) then minTokens = maxTokens end end) local maxSlider = LengthSection:Slider({ ["Title"] = "Max Tokens", ["Description"] = "Tokens are 1-3 letters", ["Min"] = 0, ["Max"] = maxTokensBound, ["Default"] = 120, }, function(n) maxTokens = math.round(n) if minTokens and (maxTokens < minTokens) then maxTokens = minTokens end end) local ChatCategory = Window:Category("Chat",noImg) local GameChatButton = ChatCategory:Button("Game Chat",noImg) local PromptButton = ChatCategory:Button("Prompt",noImg) local gameChatSection = GameChatButton:Section("Conversation", "Right") local chatParamSection = GameChatButton:Section("Chat Parameters", "Left") local apiSection = GameChatButton:Section("API Settings", "Right") --here local HttpService = game:GetService("HttpService"); local selfPrompt local noResponseToTags local cooldown local maxDis local nameprefix local chatOnNearby local sayName local selfChatOnly local ModelPrefix = false function getPrefix() local modelname if (ModelPrefix == true) then local f = cModelName:find("%(") if (f) then f = f - 2 modelname = cModelName:sub(1, f) else modelname = cModelName end modelname = "(" .. modelname .. ")" elseif (ModelPrefix == false) then modelname = nameprefix end if (modelname) then return(modelname) else return("error!") end end chatParamSection:Checkbox({ ["Title"] = "Self Prompt Only", ["Description"] = "Overrides options below", ["Default"] = false, }, function(bool) selfChatOnly = bool end) chatParamSection:Checkbox({ ["Title"] = "Self Prompt", ["Description"] = "AI Responds to you", ["Default"] = true, }, function(bool) selfPrompt = bool end) chatParamSection:Checkbox({ ["Title"] = "Respond to Tags", ["Description"] = "Responds to tagged messages", ["Default"] = true, }, function(bool) noResponseToTags = not bool end) chatParamSection:Checkbox({ ["Title"] = "Say Their Name", ["Description"] = "Says Display Name", ["Default"] = true, }, function(bool) sayName = bool end) chatParamSection:Checkbox({ ["Title"] = "Chat With Nearby", ["Description"] = "Prompted by nearby people", ["Default"] = true, }, function(bool) chatOnNearby = bool end) chatParamSection:Checkbox({ ["Title"] = "Model Prefix", ["Description"] = "Text before ai chat will be used model", ["Default"] = false, }, function(bool) ModelPrefix = bool end) chatParamSection:Slider({ ["Title"] = "Max Dis", ["Description"] = "Distance to trigger ai", ["Min"] = 3, ["Max"] = 100, ["Default"] = 16, },function(n) maxDis = n end) chatParamSection:Slider({ ["Title"] = "Chat Cooldown", ["Description"] = "In 1/100s of seconds", ["Min"] = 0, ["Max"] = 500, ["Default"] = 200, },function(n) cooldown = n/100 end) chatParamSection:Textbox({ ["Title"] = "Custom Chat Prefix", ["Description"] = "Model Prefix must be off", ["Default"] = "(RoGPT)", }, function(s) nameprefix = s end) local showAPIRequests apiSection:Toggle({ ["Title"] = "Notify Requests", ["Description"] = "Shows API Requests", ["Default"] = false, }, function(bool) showAPIRequests = bool end) pastinputs = {} pastresponses = {} local previousMessage = "" local notifyRequests = false --reset ai conversation gameChatSection:Button({ ["Title"] = "Reset Conversation", ["Description"] = "Resets AI convo", ["ButtonName"] = "Reset", }, function() pastinputs = {} pastresponses = {} Window:Notification({ ["Title"] = "RoGPT", ["Desc"] = "AI Converstion Reset", ["expire"] = 2.5, }) end) --clear debounce gameChatSection:Button({ ["Title"] = "Clear Debounce", ["Description"] = "Click if AI stopped", ["ButtonName"] = "Clear", }, function() Debounce = false Window:Notification({ ["Title"] = "RoGPT", ["Desc"] = "Debounce Cleared", ["expire"] = 2, }) end) --[[ local temperature local repPenalty local topK local topP local useTopK local useTopP local minTokens local maxTokens ]] local function MakeRequest(Prompt) local jsonPrompt if cModel == "https://api-inference.huggingface.co/models/bigscience/bloom" then jsonPrompt = { ["inputs"] = tostring(Prompt) --[[["parameters"] = { -- must be float ["repetition_penalty"] = repPenalty, ["temperature"] = temperature, ["max_time"] = 3.1, ["min_length"] = minTokens, ["max_length"] = maxTokens, ["top_k"] = (useTopK and top_k) or nil, ["top_p"] = (useTopP and top_p) or nil },]] } else jsonPrompt = { ["inputs"] = { ["past_user_inputs"] = pastinputs, ["generated_responses"] = pastresponses, ["text"] = tostring(Prompt), }, ["parameters"] = { -- must be float ["repetition_penalty"] = repPenalty, ["temperature"] = temperature, ["max_time"] = 3.1, ["min_length"] = minTokens, ["max_length"] = maxTokens, ["top_k"] = (useTopK and top_k) or nil, ["top_p"] = (useTopP and top_p) or nil }, } end 	local request = httprequest({ 		Url = cModel, 		Method = "POST", 		Headers = { 		 ["Content-Type"] = "application/json", 			["Authorization"] = "Bearer " .. api_key, 		}, 		Body = HttpService:JSONEncode(jsonPrompt); 	}); 	 	 for i,v in pairs(request) do print(i,v) end local decode if (request.Body) then decode = HttpService:JSONDecode(request.Body) end local response if (decode) then if (decode.Success and decode.Success == false) then Window:Notification({ ["Title"] = "RoGPT", ["Desc"] = "Error. No success", ["expire"] = 7, }) Debounce = false return false end if decode.error and (decode.error ~= nil or decode.error == true) then Window:Notification({ ["Title"] = "RoGPT", ["Desc"] = "Error. Likely loading", ["expire"] = 7, }) return false end Debounce = false response = decode.generated_text return response end return false end local rs = game:GetService("ReplicatedStorage") local events = rs.DefaultChatSystemChatEvents local msgRequest = events.SayMessageRequest local LocalPlayer = game.Players.LocalPlayer local OnMessageDoneFiltering = events:WaitForChild("OnMessageDoneFiltering"); local timeSinceMessage = 0 function chatToGame(message,cd) print(message, cd) Debounce = true if #message <= 200 then msgRequest:FireServer(getPrefix() .. " " .. message, "All") else msgRequest:FireServer(getPrefix() .. " " .. message:sub(1,200), "All") for i = 200,#message,200 do msgRequest:FireServer(getPrefix() .. " " .. message:sub(i, i+200), "All") end end wait(cd) Debounce = false timeSinceMessage = 0 end randomMessages = { "Hey RoGPT! Whats up?", "Hey RoGPT, did you know that I'm your creator?", "RoGPT are you bored yet?", "RoGPT do you think they should donate to me?", "ROGPT, they should donate to me, right?", "How was your day?", "How's it going?", "Whats up?", "Hello.", } function sayRandMessage() local r = randomMessages[math.random(1,#randomMessages)] msgRequest:FireServer(r, "All") end local timedSection = GameChatButton:Section("Idle Events", "Right") local RandMessageSay local ConvoReset local sayRandMessageInterval local resetConvoInterval timedSection:Toggle({ ["Title"] = "Idle Random Messages", ["Description"] = "Says messages after no chat", ["Default"] = false, }, function(bool) RandMessageSay = bool end) timedSection:Toggle({ ["Title"] = "Idle Convo Reset", ["Description"] = "Resets convo after no chat", ["Default"] = true, }, function(bool) ConvoReset = bool end) timedSection:Slider({ ["Title"] = "Msg Interval", ["Description"] = "Chat after this much time", ["Min"] = 0, ["Max"] = 100, ["Default"] = 13, }, function(n) sayRandMessageInterval = math.round(n) end) timedSection:Slider({ ["Title"] = "Reset Interval", ["Description"] = "Reset after this much time", ["Min"] = 0, ["Max"] = 100, ["Default"] = 13, }, function(n) resetConvoInterval = math.round(n) end) spawn(function() while task.wait(1) do timeSinceMessage = timeSinceMessage + 1 if timeSinceMessage%sayRandMessageInterval == 0 and RandMessageSay == true then sayRandMessage() end if timeSinceMessage%resetConvoInterval == 0 and ConvoReset == true then pastinputs = {} pastresponses = {} Window:Notification({ ["Title"] = "RoGPT", ["Desc"] = "AI Converstion Reset", ["expire"] = 2.5, }) end end end) local counter = 0 local function debugtest() return false end OnMessageDoneFiltering.OnClientEvent:Connect(function(Table) print(getPrefix()) spawn(function() local s,e = pcall(function() if (chatOnNearby == false) then return end --define variables 	local msg, instance = Table.Message, game.Players:FindFirstChild(Table.FromSpeaker); 	local c = instance and instance.Character 	local hmr = c:FindFirstChild("HumanoidRootPart") 	--checks 	if (selfChatOnly and instance.Name ~= game.Players.LocalPlayer.Name) then return end; 	if (instance == LocalPlayer and selfPrompt == false) then return end; 	if (string.match(msg, "#") and noResponseToTags == true) then return end; 	if not c or not c:FindFirstChild("Head") or not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("Head") then return end; if not hmr or LocalPlayer:DistanceFromCharacter(hmr.Position) >= maxDis then return end 	if Debounce == true then return end; --Debounce = true counter = counter + 1 if (showAPIRequests == true) then print('sent request: ', counter) Window:Notification({ ["Title"] = "RoGPT", ["Desc"] = "API Request Sent. ID: " .. counter, ["expire"] = 2.6, }) end Debounce = true local response = MakeRequest(msg) Debounce = false --local response = debugtest(msg) if (showAPIRequests == true) then print('received request: ', counter) Window:Notification({ ["Title"] = "RoGPT", ["Desc"] = "API Request Received. ID: " .. counter, ["expire"] = 2.6, }) end if not response then warn("NO RESPONSE") return end if (sayName == true) then chatToGame(game.Players:FindFirstChild(instance.Name).DisplayName .. ", " .. response,cooldown) else chatToGame(response,cooldown) end table.insert(pastinputs, msg) table.insert(pastresponses, response) end) if not s then Window:Notification({ ["Title"] = "RoGPT", ["Desc"] = "ERROR: " .. tostring(e), }) warn(e) end end) end) local PromptSection = PromptButton:Section("Prompt", "Left") local cPrompt PromptSection:Textbox({ ["Title"] = "Enter Prompt", ["Description"] = "Prompt RoGPT with text", ["Default"] = "Hello. How's it going?", },function(s) cPrompt = s end) PromptSection:Button({ ["Title"] = "Send Prompt", ["Description"] = "Send to RoGPT", ["ButtonName"] = "Send", }, function() spawn(function() local response = MakeRequest(cPrompt) if response then Debounce = false chatToGame(response, cooldown) table.insert(pastinputs, msg) table.insert(pastresponses, response) end end) end) 
